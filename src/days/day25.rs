fn run_transformation_loop(input: i128, subject: i128) -> i128 {
    (input * subject) % 20201227
}

fn run_transformation(subject: i128, loopsize: i32) -> i128 {
    let mut result = 1;
    for _i in 0..loopsize {
        result = run_transformation_loop(result, subject);
    }
    result
}

#[test]
fn test_run_transformation() {
    assert_eq!(run_transformation(7, 8), 5764801);
    assert_eq!(run_transformation(7, 11), 17807724);
    assert_eq!(run_transformation(17807724, 8), 14897079);
    assert_eq!(run_transformation(5764801, 11), 14897079);
}

pub fn puzzle1() {
    let card_pubkey: i128 = 18356117;
    let door_pubkey: i128 = 5909654;

    // Both pub keys are generated by running a number of loops (desired solution here) of the following:
    // Starting with '7' as subject number, and '1' as current value:
    // Multiply the current value by the subject number
    // Set the current value to the remainder of dividing by 20201227
    let mut card_loopsize = 0;
    let mut door_loopsize = 0;
    let mut card_value = 1;
    let mut door_value = 1;
    while card_value != card_pubkey || door_value != door_pubkey {
        if card_value != card_pubkey {
            card_value = run_transformation_loop(card_value, 7);
            card_loopsize += 1;
        }
        if door_value != door_pubkey {
            door_value = run_transformation_loop(door_value, 7);
            door_loopsize += 1;
        }
    }

    // Finally, if we have the right loop sizes, running the algorithm on the other pubkey should result
    // in the same encryption key
    println!("Puzzle 1:");
    println!(
        "Found loop values: card = {}, door = {}",
        card_loopsize, door_loopsize
    );
    println!(
        "Manual verification card: {}",
        run_transformation(door_pubkey, card_loopsize)
    );
    println!(
        "Manual verification door: {}",
        run_transformation(card_pubkey, door_loopsize)
    );
    println!("If both numbers above are the same, we got the encryption key!");
}

pub fn puzzle2() {
    // No puzzle 2 on day 25!
}
